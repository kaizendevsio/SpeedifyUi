@using XNetwork.Models
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<!-- Overall Connection Summary -->
<div class="bg-slate-800/50 border border-slate-700 rounded-xl shadow-lg mb-6 overflow-hidden">
    <div class="p-4">
        <div class="flex items-center gap-3 mb-3">
            @{
                var (status, statusColor) = GetConnectionStatus();
                var barCount = GetSignalBarCount(status);
            }
            <div class="flex items-end gap-0.5 w-10 h-6">
                @for (int i = 0; i < 4; i++)
                {
                    var isActive = i < barCount;
                    var heightClass = i switch
                    {
                        0 => "h-2",  // 25% height
                        1 => "h-3",  // 37.5% height
                        2 => "h-4",  // 50% height
                        3 => "h-6",  // 100% height
                        _ => "h-2"
                    };
                    <div class="@heightClass w-1.5 rounded-sm"
                         style="background-color: @(isActive ? GetBarColorHex(statusColor) : "#334155")"></div>
                }
            </div>
            <h3 class="font-semibold text-lg text-white">@ConnectionStatus</h3>
        </div>
        <div class="grid grid-cols-3 gap-4 text-sm">
            <div>
                <p class="text-slate-400">Latency</p>
                <p class="text-white font-bold text-xl">@Latency <span class="text-base font-medium text-slate-300">ms</span></p>
            </div>
            <div>
                <p class="text-slate-400">Download</p>
                <p class="text-white font-bold text-xl">@Download <span class="text-base font-medium text-slate-300">Mbps</span></p>
            </div>
            <div>
                <p class="text-slate-400">Upload</p>
                <p class="text-white font-bold text-xl">@Upload <span class="text-base font-medium text-slate-300">Mbps</span></p>
            </div>
        </div>
    </div>
    <div class="w-full h-12">
        <canvas id="dashboardChart"></canvas>
    </div>
</div>

@code {
    [Parameter] public string ConnectionStatus { get; set; } = "Excellent Connection";
    [Parameter] public int Latency { get; set; } = 12;
    [Parameter] public double Download { get; set; } = 85.3;
    [Parameter] public double Upload { get; set; } = 15.9;
    
    private IJSObjectReference? _chartModule;
    private bool _chartInitialized = false;
    private Timer? _chartUpdateTimer;
    private double _previousDownload = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_chartInitialized)
        {
            try
            {
                _chartModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/statisticsCharts.js");
                await _chartModule.InvokeVoidAsync("initializeDashboardSparkline", "dashboardChart");
                _chartInitialized = true;
                
                // Start timer to update sparkline every second
                _chartUpdateTimer = new Timer(async _ => await UpdateSparkline(), null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ConnectionSummary: Error initializing chart: {ex.Message}");
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        
        // Update sparkline if download speed changed
        if (_chartInitialized && Download != _previousDownload)
        {
            _previousDownload = Download;
            await UpdateSparkline();
        }
        
        // Force re-render when connection status or stats change
        await InvokeAsync(StateHasChanged);
    }

    private async Task UpdateSparkline()
    {
        if (_chartModule != null && _chartInitialized)
        {
            try
            {
                await _chartModule.InvokeVoidAsync("updateDashboardSparkline", "dashboardChart", Download);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ConnectionSummary: Error updating sparkline: {ex.Message}");
            }
        }
    }

    private (string status, string color) GetConnectionStatus()
    {
        var status = ConnectionStatus.ToLowerInvariant();
        var color = status switch
        {
            var s when s.Contains("excellent") => "green-400",
            var s when s.Contains("good") => "cyan-400",
            var s when s.Contains("fair") => "yellow-400",
            var s when s.Contains("partial") => "orange-400",
            var s when s.Contains("poor") => "red-400",
            var s when s.Contains("disconnected") || s.Contains("no connection") => "red-500",
            _ => "slate-400"
        };
        return (ConnectionStatus, color);
    }

    private int GetSignalBarCount(string status)
    {
        return status.ToLowerInvariant() switch
        {
            var s when s.Contains("excellent") => 4,  // All 4 bars
            var s when s.Contains("good") => 3,       // 3 bars
            var s when s.Contains("fair") => 2,       // 2 bars
            var s when s.Contains("partial") => 1,    // 1 bar
            var s when s.Contains("poor") => 1,       // 1 bar - Poor (red)
            _ => 0  // Disconnected or No Connection - 0 bars
        };
    }

    private string GetBarColorHex(string color)
    {
        return color switch
        {
            "green-400" => "#4ade80",
            "cyan-400" => "#22d3ee",
            "yellow-400" => "#facc15",
            "orange-400" => "#fb923c",
            "red-400" => "#f87171",
            "red-500" => "#ef4444",
            "slate-400" => "#94a3b8",
            _ => "#334155" // slate-700
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_chartUpdateTimer != null)
        {
            await _chartUpdateTimer.DisposeAsync();
        }
        
        if (_chartModule != null)
        {
            try
            {
                if (_chartInitialized)
                {
                    await _chartModule.InvokeVoidAsync("disposeChart", "dashboardChart");
                }
                await _chartModule.DisposeAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ConnectionSummary: Error disposing chart: {ex.Message}");
            }
        }
    }
}